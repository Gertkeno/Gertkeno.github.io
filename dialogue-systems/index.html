<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Garrett Hale" />
  <title>Game Dialogue Systems</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../document.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#systems-intent" id="toc-systems-intent">Systems
Intent</a></li>
<li><a href="#vessels-and-virtual-machines"
id="toc-vessels-and-virtual-machines">Vessels and Virtual Machines</a>
<ul>
<li><a href="#vm---data-structures" id="toc-vm---data-structures">VM -
Data Structures</a></li>
<li><a href="#vm---operation" id="toc-vm---operation">VM -
Operation</a></li>
<li><a href="#vm---file-reader" id="toc-vm---file-reader">VM - File
Reader</a></li>
</ul></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a></li>
</ul>
</nav>
<h1 id="systems-intent">Systems Intent</h1>
<p>Dialogue can be the focus of many games, if robust dialogue is the
foremost feature then it’s important to create or use a system that can
account for the plethora of data and logistics behind simple game
dialogue.</p>
<p>Some games, like Morrowind use dialogue for linear quest
interactions, and Morrowind houses a healthy amount of quests. In this
scenario the game needs to track multiple quest progressions, though
that’s the end of it, linear state. <a
href="https://openmw.org/en/">OpenMW</a>, a fan re-write of the
Morrowind engine has fairly legible quest code available <a
href="https://github.com/OpenMW/openmw/tree/master/apps/openmw/mwdialogue">here</a>.</p>
<p>Telltale’s “The Walking Dead” uses a branching paths story in a
hierarchic structure, one choice always leads to a new choice, never
repeating. The hierarchy inherently provides structure used to create
branches and reduce branches back into a linear path.</p>
<p>Our team’s game “Vessels”, we had a finite cast of characters and a
spider-web of dialogue for the player to unravel. We used <a
href="https://twinery.org/">Twinery</a> to draft our story as the
node-based system and robust state machine handles our cyclical,
evolving story. In Unreal we developed our own virtual machine to handle
dialogue, sewing programming and dialogue into one text file. With a
virtual machine like this we could create branching paths and out of
order execution for player progression.</p>
<p>When designing any system it’s important to only pay for what you
use. Having a firmly low scope means saying no to some requests, it
means building a system that simply can’t do everything. By design the
limitations can bring benefits, you can make assumptions of what
designers are trying to do and automatically react or properly throw
errors. It’s very easy to believe you’ll need the most robust system,
this rarely reduces time spent coding for both the tools developer and
content creators.</p>
<p>It’s very important to make sure your system can be debugged, even
those not using virtual machines or a seemingly simple system. Error
checking is little work when automated and a major headache if left
invisible.</p>
<h1 id="vessels-and-virtual-machines">Vessels and Virtual Machines</h1>
<p>Vessels originally planned for a open world approach. The tool <a
href="https://www.inklestudios.com/ink/"><em>ink</em></a> seemed
promising, but didn’t fit our proposed design requirements. Looking at
it now we seem to have implemented most of <em>ink</em>’s features and
architecture with more legible syntax, if it worked with Unreal and I
dug deeper I’m sure we would’ve picked this tool. <a
href="https://twinery.org/"><em>Twinery</em></a> is another tool we
would use for our initial draft. <em>Twinery</em> doesn’t export to a
easy to parse format, nor work out of the box with Unreal, it was useful
to find out what features we would need.</p>
<p>I didn’t look into <a
href="https://github.com/exodrifter/unity-rumor"><em>Rumor</em></a> at
the time, but it’s a fruitful dialogue system with fantastic, simple
syntax.</p>
<p>The benefit of a virtual machine like <em>ink</em> or the “Airlock
Dialogue File” (<em>ADF</em>) is allowing designers immense control over
pathways and state changes. It’s important to only cater to those two
objectives, too many features can bog down your dialogue systems ease of
use or overcomplicate simple functions. <em>ADF</em> for example only
stores boolean flags, no integers or math allowed.</p>
<p>When restraining scope and curbing potential downsides virtual
machines flourish, <em>ADF</em> handles 6,923 lines of dialogue with
7,258 written operators for flow control. This would’ve been over 7,258
nodes in blueprint without this system to ease reading and writing; not
to mention cut out Unreal’s atrocious boot time.</p>
<h2 id="vm---data-structures">VM - Data Structures</h2>
<p>A virtual machine uses programmer-defined instructions to operate on.
The performance of virtual machines is always slower than raw machine
code, yet can be much faster than most interpreted languages if the
instructions are small and specific.</p>
<p>We will define game or dialogue related instructions. <em>ADF</em>
has no mathematics built-in, every operation is built to aid in dialogue
cosmetics and flow. Code samples like below will be shortened and
<em>UE4</em> types will be replaced with <em>stl</em> variants.</p>
<p>As reference I’ve attached this sample of dialogue the <em>ADF</em>
parses and uses in our game.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Question_Suicide</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Yes... I am. And... I&#39;ve asked you to not talk to me about this.</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    ~name: Esme</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Peyton, please... I respect the subjects you don&#39;t want to discuss.</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Please do not bring Marv up with me.</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>This subject seems to upset her most...</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    ~name: Entity</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    ~interest: Esme_Upset by Marv&#39;s suicide</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>We can use this.</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    ~link: ASPEYTON_QUESTION</span></code></pre></div>
<p>Each piece of dialogue and function (the ~ part) is stored as a
“byte” in the machine. “Byte” used lightly as we keep the whole string
in this bytecode rather than referencing it elsewhere in memory.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Byte</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="dt">EType_t</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// COSMETIC</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        SAID_TEXT<span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        CHOICE_TEXT<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        NAME<span class="op">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// CONDITIONALS</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        CONDITIONAL<span class="op">,</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        INVERSE_CONDITIONAL<span class="op">,</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        OR_CONDITIONAL<span class="op">,</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        ALREADY_READ<span class="op">,</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        AS_CREW<span class="op">,</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// MUTATORS</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        SET<span class="op">,</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        UNSET<span class="op">,</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        INTEREST<span class="op">,</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        SPECIAL<span class="op">,</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// FLOW CONTROL</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        ALTER_START<span class="op">,</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        LINK_TO<span class="op">,</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        BREAK_TO<span class="op">,</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> function<span class="op">;</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>text<span class="op">;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> originLine<span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> indent<span class="op">;</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>So we create each byte with two main variables for our machine to
operate on. Each <code>EType_t</code> tells the VM what to do with the
byte’s <code>text</code> variable, for merely displaying, a
<code>SAID_TEXT</code> operator will print the <code>text</code>
variable on-screen. The <code>SET</code> function will store a value of
true in the VM, with <code>text</code> as the key, for later state
retrieval.</p>
<p>To help understand how we craft our Byte I’ll take the last example
and write it as a array in C++ using the <code>struct Byte</code>.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>Byte Question_Suicide<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>SAID_TEXT<span class="op">,</span> <span class="st">&quot;Yes... I am. And... I&#39;ve asked you to not talk to me about this.&quot;</span><span class="op">},</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>NAME<span class="op">,</span>      <span class="st">&quot;Esme&quot;</span><span class="op">},</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>SAID_TEXT<span class="op">,</span> <span class="st">&quot;Peyton, please... I respect the subjects you don&#39;t want to discuss.&quot;</span><span class="op">},</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>SAID_TEXT<span class="op">,</span> <span class="st">&quot;Please do not bring Marv up with me.&quot;</span> <span class="op">},</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>SAID_TEXT<span class="op">,</span> <span class="st">&quot;This subject seems to upset her most...&quot;</span><span class="op">},</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>NAME<span class="op">,</span>      <span class="st">&quot;Entity&quot;</span><span class="op">},</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>INTEREST<span class="op">,</span>  <span class="st">&quot;Esme_Upset by Marv&#39;s suicide&quot;</span><span class="op">},</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>SAID_TEXT<span class="op">,</span> <span class="st">&quot;We can use this.&quot;</span><span class="op">},</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>Byte<span class="op">::</span>LINK_TO<span class="op">,</span>   <span class="st">&quot;ASPEYTON_QUESTION&quot;</span><span class="op">},</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>If we track the last read <code>SAID_TEXT</code> operator and re-feed
the list at that start point; making <code>SAID_TEXT</code> the “end”
for an iteration. We can use this pattern to wait for user input “click
to continue” before iterating to the next <code>SAID_TEXT</code>.</p>
<p>This example code conversion is mostly accurate with the caveat that
we can’t create a custom named <code>Question_Suicide</code> array for
what’s declared in a text file. We opted to use a
<code>std::map &lt;std::string, std::list &lt;Byte&gt;&gt;</code> to
achieve this run-time array creation, where the <code>std::string</code>
key is “Question_Suicide” and the rest, is the byte-string in linked
list form.</p>
<blockquote>
<p>When actually implementing I’d use <a
href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a>
and <a
href="https://en.cppreference.com/w/cpp/container/forward_list"><code>std::forward_list</code></a>
for simpler insertion complexity.</p>
</blockquote>
<p>Byte-strings can take form of many data structures. Arrays will be
faster to operate on but potentially slower to build. Linked lists will
be easy to build and slower to operate. For this reason our dialogue
system builds linked lists at the start of the game and operates over
them during dialogue. Maps are surprisingly fast for how feature rich
they are; we use maps to title and track the dialogue byte-strings.</p>
<p>Dialogue will be running our virtual machine sparsely, only when the
player clicks through text, so performance at vm-runtime is typically
wasted effort.</p>
<h2 id="vm---operation">VM - Operation</h2>
<p>The simplest virtual machine is a function taking some container to
operate over; I’ll demonstrate the easiest, hardest to work with
implementation.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> run_string <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>forward_list<span class="op"> &lt;</span>Byte<span class="op">&gt;</span> data<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span> i<span class="op">:</span> data<span class="op">)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>i<span class="op">.</span>function<span class="op">)</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Byte<span class="op">::</span>SAID_TEXT<span class="op">:</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> i<span class="op">.</span>text <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Byte<span class="op">::</span>LINK_TO<span class="op">:</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            run_string <span class="op">(</span>data_lookup <span class="op">(</span>i<span class="op">.</span>text<span class="op">));</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;unhandled function!&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This function may be enough for you, but I’d like to leverage objects
to make some relationships between our dialogue and actors. Firstly any
data from our byte-strings will be lost without somewhere to keep it.
Second this operates an entire byte-string at a time, while useful for
more programmatic cases we need to stop, and wait for the player to
continue the reading. By making a class to house and run our dialogue we
can attach this to actors and directly associate text with them.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VM</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// loads text file into our &quot;dialogue&quot; variable</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    VM <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span> filename<span class="op">);</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> byte_itr <span class="op">=</span> <span class="bu">std::</span>forward_list<span class="op"> &lt;</span>Byte<span class="op">&gt;::</span>const_iterator<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// operates based on the playHead</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> run_head<span class="op">();</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// variables can be anything!</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_set<span class="op"> &lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> flags<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// what a mouthful!</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op"> &lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>forward_list<span class="op"> &lt;</span>Byte<span class="op">&gt;&gt;</span> dialogue<span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// track dialogue progression</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    byte_itr playHead<span class="op">,</span> playHeadEnd<span class="op">;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>In <em>UE4</em> finding a place for persistent data may be daunting.
Creating a basic C++ “Game Instance” class with accessible data will
persist through the game, just remember to reset during a game over or
save/load. With this your VM function will pull and push data from
<em>UE4</em>’s global variables, like the game instance object.</p>
<p>For this document I’m going to continue with the custom VM class
definition.</p>
<p>When managing dialogue you’ll likely want to display text, change
state, and move the play head forward. We benefit from separating this
into at least two functions, you might want to display text more than
once, or skip ahead via a fast-forward key.</p>
<p>It’s also important to find out what data needs to come out of your
VM operations. For displaying text it’s usually just a
<code>std::string</code>, while running could return full state, a error
code, or nothing! My advice here will be to try and catch your errors
while loading dialogue.</p>
<p>Conditional statements probably operate the same when running or
reading, so we can move this to it’s own function as well.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VM</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    VM <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span> filename<span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> byte_itr <span class="op">=</span> <span class="bu">std::</span>forward_list<span class="op"> &lt;</span>Byte<span class="op">&gt;::</span>const_iterator<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// returns if the run was successful</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> run_head<span class="op">();</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// returns text to display, may be empty</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>read_head<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// returns a change in state</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> byte_state <span class="op">(</span><span class="dt">bool</span> inState<span class="op">,</span> <span class="at">const</span> Byte <span class="op">&amp;</span> in<span class="op">)</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_set<span class="op"> &lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> flags<span class="op">;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op"> &lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>forward_list<span class="op"> &lt;</span>Byte<span class="op">&gt;&gt;</span> dialogue<span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    byte_itr playHead<span class="op">,</span> playHeadEnd<span class="op">;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Implementing these functions is very similar to the stand alone
function I wrote before. The <em>ADF</em> structure requires
byte-strings to start with <code>SAID_TEXT</code>, we specify this so we
can use <code>SAID_TEXT</code> as a sentential to halt. When the VM
picks back up we can grantee <code>playHead</code> is either
<code>SAID_TEXT</code> or <code>playHeadEnd</code>.</p>
<p>Re-writing the standalone <code>run_string()</code> example function
for our class certainly looks larger, but the logic now checks for our
sentinel and holds the play head properly.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> VM<span class="op">::</span>run_head<span class="op">()</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>playHead <span class="op">==</span> playHeadEnd<span class="op">)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// our run_head() should always start on a SAID_TEXT, or end</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    playHead<span class="op">++;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>playHead <span class="op">!=</span> playHeadEnd <span class="kw">and</span> playHead<span class="op">-&gt;</span>function <span class="op">!=</span> Byte<span class="op">::</span>SAID_TEXT<span class="op">)</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>playHead<span class="op">-&gt;</span>function<span class="op">)</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Byte<span class="op">::</span>SAID_TEXT<span class="op">:</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> playHead<span class="op">-&gt;</span>text <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Byte<span class="op">::</span>LINK_TO<span class="op">:</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>                <span class="at">const</span> <span class="kw">auto</span> headText <span class="op">{</span>playHead<span class="op">-&gt;</span>text<span class="op">};</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">// be weary, unordered_map::at() will throw</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">// if headText isn&#39;t a valid key!</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                playHead <span class="op">=</span> dialogue<span class="op">.</span>at <span class="op">(</span>headText<span class="op">).</span>begin<span class="op">();</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                playHeadEnd <span class="op">=</span> dialogue<span class="op">.</span>at <span class="op">(</span>headText<span class="op">).</span>end<span class="op">();</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        playHead<span class="op">++;</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="vm---file-reader">VM - File Reader</h2>
<p>Constructing our byte-strings by reading the text files first
requires formatting. I really like <a
href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">markdown</a>
so I based <em>ADF</em> around it. A line-based formatting approach
makes for easy programming, and can interfere with stylized/rich text
formatting like <a href="http://www.pindari.com/rtf1.html">RTF</a>.</p>
<p>When creating <em>ADF</em>’s formatting we only had to consider two
parts; how to assign byte-strings a name for later reference, and how to
specify the type per byte. Naming byte-strings was easy, any special
character(s) to make a line or block stand out will do. Now specifying
byte type certainly needs to be a key-value pair with some short hands
for common functions.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Esme_Success</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>I&#39;ll be right there.</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    ~name: Esme</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>Esme is on her way.</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    ~name: Entity</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    ~set: dl_someone_enroute</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    ~set: dl_esme_spoke</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    ~special: sound_off</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="fu"># Rakesh_Success</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>Patience, if you please.</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    ~name: Rakesh</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>Rakesh is on his way.</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    ~name: Entity</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    ~set: dl_someone_enroute</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    ~set: dl_rakesh_spoke</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    ~special: sound_off</span></code></pre></div>
<p>This example shows we used ‘#’ to mark the start of a new
byte-string. We enclose byte types in <code>~function:</code> and the
byte text as anything afterwards. Lines without a
<code>~function:</code> at the start are treated as
<code>~SAID_TEXT:</code>, our shorthand.</p>
<p>Reading our line based files will look like this, proper error
checking will massively expand this constructor, but it’s well worth
it.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>VM<span class="op">::</span>VM <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span> filename<span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ifstream<span class="op"> </span>infile <span class="op">(</span>filename<span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>infile<span class="op">.</span>is_open<span class="op">())</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op"> {</span><span class="st">&quot;couldn&#39;t open file! &quot;</span> <span class="op">+</span> filename<span class="op">};</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>line<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>forward_list<span class="op"> &lt;</span>Byte<span class="op">&gt;</span> <span class="op">*</span> writingTo <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="bu">std::</span>getline<span class="op"> (</span>infile<span class="op">,</span> line<span class="op">))</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        line <span class="op">=</span> trim_whitespace <span class="op">(</span>line<span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>line <span class="op">[</span><span class="dv">0</span><span class="op">])</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="ch">&#39;#&#39;</span><span class="op">:</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we create our lists backwards with push_front()</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>writingTo <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>                writingTo<span class="op">-&gt;</span>reverse<span class="op">();</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// name new byte-string</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            writingTo <span class="op">=</span> <span class="op">&amp;</span>dialogue <span class="op">[</span>line<span class="op">.</span>substr <span class="op">(</span><span class="dv">1</span><span class="op">)];</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="ch">&#39;~&#39;</span><span class="op">:</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>writingTo <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>                <span class="co">// is function of name:</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>                <span class="at">const</span> <span class="kw">auto</span> colonPoint <span class="op">{</span>line<span class="op">.</span>find <span class="op">(</span><span class="ch">&#39;:&#39;</span><span class="op">)};</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>                <span class="at">const</span> <span class="kw">auto</span> functionName <span class="op">{</span>line<span class="op">.</span>substr <span class="op">(</span><span class="dv">1</span><span class="op">,</span> colonPoint<span class="op">-</span><span class="dv">1</span><span class="op">)};</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>                <span class="at">const</span> <span class="kw">auto</span> functionText <span class="op">{</span>trim_whitespace <span class="op">(</span>line<span class="op">.</span>substr <span class="op">(</span>colonPoint<span class="op">))};</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>                writingTo<span class="op">-&gt;</span>push_front <span class="op">(</span>Byte <span class="op">{</span>functionName<span class="op">,</span> functionText<span class="op">});</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">// is function SAID_TEXT</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>writingTo <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>                writingTo<span class="op">-&gt;</span>push_front <span class="op">(</span>Byte <span class="op">{</span>Byte<span class="op">::</span>SAID_TEXT<span class="op">,</span> line<span class="op">});</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This format is reliant on the first character on a line, this makes
it easy to expand for more shorthand or unique functions. Keep in mind
this sample code doesn’t check for any potentially extreme errors, like
reading the same <code># name</code>. Validating function inputs will be
the bulk of your error checking, it’s very important to highlight any
potential syntax or logic errors.</p>
<p>I’ll write out the <code>trim_whitespace()</code> function, and the
string based type Byte constructor for completions sake.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="bu">std::</span>string<span class="op"> </span>trim_whitespace <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span> in<span class="op">)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> index <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>index <span class="op">&lt;</span> in<span class="op">.</span>length<span class="op">()</span> <span class="kw">and</span> <span class="bu">std::</span>isspace<span class="op"> (</span>in <span class="op">[</span>index<span class="op">]))</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        index<span class="op">++;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>index <span class="op">&gt;=</span> in<span class="op">.</span>length<span class="op">()</span> <span class="kw">or</span> index <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> in<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> in<span class="op">.</span>substr <span class="op">(</span>index<span class="op">);</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>Byte<span class="op">::</span>Byte <span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>type<span class="op">,</span> <span class="bu">std::</span>string<span class="op"> </span>value<span class="op">)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> text <span class="op">(</span>value<span class="op">)</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string<span class="op"> </span>key<span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">EType_t</span> value<span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="at">static</span> <span class="at">const</span> tostr<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="st">&quot;set&quot;</span><span class="op">,</span> SET<span class="op">},</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="st">&quot;special&quot;</span><span class="op">,</span> SPECIAL<span class="op">},</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">,</span> NAME<span class="op">},</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// tolower the entire input</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>transform<span class="op"> (</span>type<span class="op">.</span>begin<span class="op">(),</span> type<span class="op">.</span>end<span class="op">(),</span> type<span class="op">.</span>begin<span class="op">(),</span> <span class="op">::</span>tolower<span class="op">);</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span> i <span class="op">:</span> tostr<span class="op">)</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i<span class="op">.</span>key <span class="op">==</span> type<span class="op">)</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>            function <span class="op">=</span> i<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>When designing a system it’s of utmost importance to consider the
following:</p>
<ol type="1">
<li>Error Checking</li>
<li>Legibility</li>
<li>Expandability</li>
</ol>
<p>While programming in general the ability to debug code should be in
the back of your head. While designers are using your system it should
be a forced, implicit part of the system. At any point stop and think
“How could this function be misused?”, “What if this is misspelled?” and
try to flag that case. Your system should check designer’s code
vigorously.</p>
<p>Writing your own language puts you in a unique situation of having to
teach it. Do yourself a favor and make it simple and transparent, use as
much English as possible. “Syntactic sugar” should be avoided, too many
enigmatic percent signs and asterisks only cause confusion and a trip to
the manual, even for yourself. I’d recommend making use of braces or
parenthesis if applicable, white space can be difficult to debug and
program for.</p>
<p>More functionality will always be around the corner, be ready to
quickly try out ideas. Make sure you can account for functions with
multiple parameters. Add an escape character in case your special
characters are needed in-dialogue.</p>
<p>Creating a virtual machine can be all the fun of making your own
language without all the hassle of compiler architecture. Good luck, try
to make the most of it!</p>
</body>
</html>
