<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Garrett Hale" />
  <title>Game Dialogue Systems</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../document.css" />
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#systems-intent">Systems Intent</a></li>
<li><a href="#vessels-and-virtual-machines">Vessels and Virtual Machines</a><ul>
<li><a href="#vm---data-structures">VM - Data Structures</a></li>
<li><a href="#vm---operation">VM - Operation</a></li>
<li><a href="#vm---file-reader">VM - File Reader</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</nav>
<h1 id="systems-intent">Systems Intent</h1>
<p>Dialogue can be the focus of many games, if robust dialogue is the foremost feature then it’s important to create or use a system that can account for the plethora of data and logistics behind simple game dialogue.</p>
<p>Some games, like Morrowind use dialogue for linear quest interactions, and Morrowind houses a healthy amount of quests. In this scenario the game needs to track multiple quest progressions, though that’s the end of it, linear state. <a href="https://openmw.org/en/">OpenMW</a>, a fan re-write of the Morrowind engine has fairly legible quest code available <a href="https://github.com/OpenMW/openmw/tree/master/apps/openmw/mwdialogue">here</a>.</p>
<p>Telltale’s “The Walking Dead” uses a branching paths story in a hierarchic structure, one choice always leads to a new choice, never repeating. The hierarchy inherently provides structure used to create branches and reduce branches back into a linear path.</p>
<p>Our team’s game “Vessels”, we had a finite cast of characters and a spider-web of dialogue for the player to unravel. We used <a href="https://twinery.org/">Twinery</a> to draft our story as the node-based system and robust state machine handles our cyclical, evolving story. In Unreal we developed our own virtual machine to handle dialogue, sewing programming and dialogue into one text file. With a virtual machine like this we could create branching paths and out of order execution for player progression.</p>
<p>When designing any system it’s important to only pay for what you use. Having a firmly low scope means saying no to some requests, it means building a system that simply can’t do everything. By design the limitations can bring benefits, you can make assumptions of what designers are trying to do and automatically react or properly throw errors. It’s very easy to believe you’ll need the most robust system, this rarely reduces time spent coding for both the tools developer and content creators.</p>
<p>It’s very important to make sure your system can be debugged, even those not using virtual machines or a seemingly simple system. Error checking is little work when automated and a major headache if left invisible.</p>
<p>Always compile <code>-Wall -Wextra</code> you cowards.</p>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
<h1 id="vessels-and-virtual-machines">Vessels and Virtual Machines</h1>
<p>Vessels originally planned for a open world approach. The tool <a href="https://www.inklestudios.com/ink/"><em>ink</em></a> seemed promising, but didn’t fit our proposed design requirements. Looking at it now we seem to have implemented most of <em>ink</em>’s features and architecture with more legible syntax, if it worked with Unreal and I dug deeper I’m sure we would’ve picked this tool. <a href="https://twinery.org/"><em>Twinery</em></a> is another tool we would use for our initial draft. <em>Twinery</em> doesn’t export to a easy to parse format, nor work out of the box with Unreal, it was useful to find out what features we would need.</p>
<p>I didn’t look into <a href="https://github.com/exodrifter/unity-rumor"><em>Rumor</em></a> at the time, but it’s a fruitful dialogue system with fantastic, simple syntax.</p>
<p>The benefit of a virtual machine like <em>ink</em> or the “Airlock Dialogue File” (<em>ADF</em>) is allowing designers immense control over pathways and state changes. It’s important to only cater to those two objectives, too many features can bog down your dialogue systems ease of use or overcomplicate simple functions. <em>ADF</em> for example only stores boolean flags, no integers or math allowed.</p>
<p>When restraining scope and curbing potential downsides virtual machines flourish, <em>ADF</em> handles 6,923 lines of dialogue with 7,258 written operators for flow control. This would’ve been over 7,258 nodes in blueprint without this system to ease reading and writing; not to mention cut out Unreal’s atrocious boot time.</p>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
<h2 id="vm---data-structures">VM - Data Structures</h2>
<p>First off a quick “VM 101”. We’ll fudge some of the specifics here but a virtual machine uses programmer-defined bytecode instructions to operate on top of your standard CPU instructions. The performance of virtual machines is always slower than raw machine code, yet faster than most interpreted languages.</p>
<p>You should define specific game or dialogue related bytecode. <em>ADF</em> has no mathematics built-in, every operation is built to aid in dialogue cosmetics and flow. Code samples like below will be shortened and <em>UE4</em> types will be replaced with <em>stl</em> variants.</p>
<p>As reference I’ve attached this sample of dialogue the <em>ADF</em> parses and uses in our game.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb1-1" title="1"><span class="fu"># Question_Suicide</span></a>
<a class="sourceLine" id="cb1-2" title="2">Yes... I am. And... I&#39;ve asked you to not talk to me about this.</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bn">    ~name: Esme</span></a>
<a class="sourceLine" id="cb1-4" title="4">Peyton, please... I respect the subjects you don&#39;t want to discuss.</a>
<a class="sourceLine" id="cb1-5" title="5">Please do not bring Marv up with me.</a>
<a class="sourceLine" id="cb1-6" title="6">This subject seems to upset her most...</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="bn">    ~name: Entity</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="bn">    ~interest: Esme_Upset by Marv&#39;s suicide</span></a>
<a class="sourceLine" id="cb1-9" title="9">We can use this.</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="bn">    ~link: ASPEYTON_QUESTION</span></a></code></pre></div>
<p>Each piece of dialogue and function (the ~ part) is stored as a “byte” in the machine. “Byte” used lightly as we keep the whole string in this bytecode rather than referencing it elsewhere in memory.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">struct</span> Byte</a>
<a class="sourceLine" id="cb2-2" title="2">{</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">enum</span> <span class="dt">EType_t</span></a>
<a class="sourceLine" id="cb2-4" title="4">    {</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="co">// COSMETIC</span></a>
<a class="sourceLine" id="cb2-6" title="6">        SAID_TEXT,</a>
<a class="sourceLine" id="cb2-7" title="7">        CHOICE_TEXT,</a>
<a class="sourceLine" id="cb2-8" title="8">        NAME,</a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">        <span class="co">// CONDITIONALS</span></a>
<a class="sourceLine" id="cb2-11" title="11">        CONDITIONAL,</a>
<a class="sourceLine" id="cb2-12" title="12">        INVERSE_CONDITIONAL,</a>
<a class="sourceLine" id="cb2-13" title="13">        OR_CONDITIONAL,</a>
<a class="sourceLine" id="cb2-14" title="14">        ALREADY_READ,</a>
<a class="sourceLine" id="cb2-15" title="15">        AS_CREW,</a>
<a class="sourceLine" id="cb2-16" title="16"></a>
<a class="sourceLine" id="cb2-17" title="17">        <span class="co">// MUTATORS</span></a>
<a class="sourceLine" id="cb2-18" title="18">        SET,</a>
<a class="sourceLine" id="cb2-19" title="19">        UNSET,</a>
<a class="sourceLine" id="cb2-20" title="20">        INTEREST,</a>
<a class="sourceLine" id="cb2-21" title="21">        SPECIAL,</a>
<a class="sourceLine" id="cb2-22" title="22"></a>
<a class="sourceLine" id="cb2-23" title="23">        <span class="co">// FLOW CONTROL</span></a>
<a class="sourceLine" id="cb2-24" title="24">        ALTER_START,</a>
<a class="sourceLine" id="cb2-25" title="25">        LINK_TO,</a>
<a class="sourceLine" id="cb2-26" title="26">        BREAK_TO,</a>
<a class="sourceLine" id="cb2-27" title="27">    } function;</a>
<a class="sourceLine" id="cb2-28" title="28"></a>
<a class="sourceLine" id="cb2-29" title="29">    <span class="bu">std::</span>string text;</a>
<a class="sourceLine" id="cb2-30" title="30"></a>
<a class="sourceLine" id="cb2-31" title="31">    <span class="dt">unsigned</span> originLine;</a>
<a class="sourceLine" id="cb2-32" title="32">    <span class="dt">unsigned</span> indent;</a>
<a class="sourceLine" id="cb2-33" title="33">};</a></code></pre></div>
<p>Structurally, this isn’t what most people expect, and sadly that means I’ve created a poor mental model for you.</p>
<p>So we create each byte with two main variables for our machine to operate on. Each <code>EType_t</code> tells the VM what to do with the byte’s <code>text</code> variable, for merely displaying, a <code>SAID_TEXT</code> operator will print the <code>text</code> variable on-screen. The <code>SET</code> function will store a value of true in the VM, with <code>text</code> as the key, for later state retrieval.</p>
<p>To help understand how we craft our Byte I’ll take the last example and write it as a array in C++ using the <code>struct Byte</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">Byte Question_Suicide[] = {</a>
<a class="sourceLine" id="cb3-2" title="2">    {Byte::SAID_TEXT, <span class="st">&quot;Yes... I am. And... I&#39;ve asked you to not talk to me about this.&quot;</span>},</a>
<a class="sourceLine" id="cb3-3" title="3">    {Byte::NAME,      <span class="st">&quot;Esme&quot;</span>},</a>
<a class="sourceLine" id="cb3-4" title="4">    {Byte::SAID_TEXT, <span class="st">&quot;Peyton, please... I respect the subjects you don&#39;t want to discuss.&quot;</span>},</a>
<a class="sourceLine" id="cb3-5" title="5">    {Byte::SAID_TEXT, <span class="st">&quot;Please do not bring Marv up with me.&quot;</span> },</a>
<a class="sourceLine" id="cb3-6" title="6">    {Byte::SAID_TEXT, <span class="st">&quot;This subject seems to upset her most...&quot;</span>},</a>
<a class="sourceLine" id="cb3-7" title="7">    {Byte::NAME,      <span class="st">&quot;Entity&quot;</span>},</a>
<a class="sourceLine" id="cb3-8" title="8">    {Byte::INTEREST,  <span class="st">&quot;Esme_Upset by Marv&#39;s suicide&quot;</span>},</a>
<a class="sourceLine" id="cb3-9" title="9">    {Byte::SAID_TEXT, <span class="st">&quot;We can use this.&quot;</span>},</a>
<a class="sourceLine" id="cb3-10" title="10">    {Byte::LINK_TO,   <span class="st">&quot;ASPEYTON_QUESTION&quot;</span>},</a>
<a class="sourceLine" id="cb3-11" title="11">};</a></code></pre></div>
<p>A typical virtual machine will try to read the whole byte-string or finish prematurely, throw an error, and give up. If we track the last read <code>SAID_TEXT</code> operator and re-feed the list at that start point; making <code>SAID_TEXT</code> the “end” byte like <code>'\0'</code> for c-strings. We can use this pattern to wait for user input “click to continue” before reading the next <code>SAID_TEXT</code>.</p>
<p>This example code conversion is mostly accurate with the caveat that we can’t create a custom named <code>Question_Suicide</code> array for what’s declared in a text file. We opted to use a <code>std::map &lt;std::string, std::list &lt;Byte&gt;&gt;</code> to achieve this run-time array creation, where the <code>std::string</code> key is “Question_Suicide” and the rest, is the byte-string in linked list form.</p>
<blockquote>
<p>When actually implementing I’d use <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a> and <a href="https://en.cppreference.com/w/cpp/container/forward_list"><code>std::forward_list</code></a> for simpler insertion complexity.</p>
</blockquote>
<p>Byte-strings can take form of many data structures. Arrays will be faster to operate on but potentially slower to build. Linked lists will be easy to build and slower to operate. For this reason our dialogue system builds linked lists at the start of the game and operates over them during dialogue. Maps are surprisingly fast for how feature rich they are; we use maps to title and track the dialogue byte-strings.</p>
<p>Dialogue will be running our virtual machine sparsely, only when the player clicks through text, so performance at vm-runtime is typically wasted effort.</p>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
<h2 id="vm---operation">VM - Operation</h2>
<p>The simplest virtual machine is a function taking some container to operate over; I’ll demonstrate the easiest, hardest to work with implementation.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">bool</span> run_string (<span class="at">const</span> <span class="bu">std::</span>forward_list &lt;Byte&gt; data)</a>
<a class="sourceLine" id="cb4-2" title="2">{</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="cf">for</span> (<span class="kw">auto</span> &amp; i: data)</a>
<a class="sourceLine" id="cb4-4" title="4">    {</a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="cf">switch</span> (i.function)</a>
<a class="sourceLine" id="cb4-6" title="6">        {</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="cf">case</span> Byte::SAID_TEXT:</a>
<a class="sourceLine" id="cb4-8" title="8">            <span class="bu">std::</span>cout &lt;&lt; i.text &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb4-9" title="9">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="cf">case</span> Byte::LINK_TO:</a>
<a class="sourceLine" id="cb4-11" title="11">            run_string (data_lookup (i.text));</a>
<a class="sourceLine" id="cb4-12" title="12">            <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb4-13" title="13">        <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb4-14" title="14">            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;unhandled function!&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb4-15" title="15">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb4-16" title="16">        }</a>
<a class="sourceLine" id="cb4-17" title="17">    }</a>
<a class="sourceLine" id="cb4-18" title="18">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb4-19" title="19">}</a></code></pre></div>
<p>This function may be enough for you, but I’d like to leverage objects to make some relationships between our dialogue and actors. Firstly any data from our byte-strings will be lost without somewhere to keep it. Second this operates an entire byte-string at a time, while useful for more programmatic cases we need to stop, and wait for the player to continue the reading. By making a class to house and run our dialogue we can attach this to actors and directly associate text with them.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> VM</a>
<a class="sourceLine" id="cb5-2" title="2">{</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="co">// loads text file into our &quot;dialogue&quot; variable</span></a>
<a class="sourceLine" id="cb5-5" title="5">    VM (<span class="at">const</span> <span class="bu">std::</span>string &amp; filename);</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">using</span> byte_itr = <span class="bu">std::</span>forward_list &lt;Byte&gt;::const_iterator;</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="co">// operates based on the playHead</span></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="dt">void</span> run_head();</a>
<a class="sourceLine" id="cb5-11" title="11"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="co">// variables can be anything!</span></a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="bu">std::</span>unordered_set &lt;<span class="bu">std::</span>string&gt; flags;</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="co">// what a mouthful!</span></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="bu">std::</span>unordered_map &lt;<span class="bu">std::</span>string, <span class="bu">std::</span>forward_list &lt;Byte&gt;&gt; dialogue;</a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="co">// track dialogue progression</span></a>
<a class="sourceLine" id="cb5-19" title="19">    byte_itr playHead, playHeadEnd;</a>
<a class="sourceLine" id="cb5-20" title="20">};</a></code></pre></div>
<p>In <em>UE4</em> finding a place for persistent data may be daunting. Creating a basic C++ “Game Mode” class with accessible data will persist through the game, just remember to reset during a game over or save/load. With this your VM function will pull and push data from <em>UE4</em>’s global variables, like the game mode object.</p>
<p>For this document I’m going to continue with the custom VM class definition.</p>
<p>When managing dialogue you’ll likely want to display text, change state, and move the play head forward. We benefit from separating this into at least two functions, you might want to display text more than once, or skip ahead via a fast-forward key.</p>
<p>It’s also important to find out what data needs to come out of your VM operations. For displaying text it’s usually just a <code>std::string</code>, while running could return full state, a error code, or nothing! My advice here will be to try and catch your errors while loading dialogue.</p>
<p>Conditional statements probably operate the same when running or reading, so we can move this to it’s own function as well.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">class</span> VM</a>
<a class="sourceLine" id="cb6-2" title="2">{</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb6-4" title="4">    VM (<span class="at">const</span> <span class="bu">std::</span>string &amp; filename);</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">using</span> byte_itr = <span class="bu">std::</span>forward_list &lt;Byte&gt;::const_iterator;</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="co">// returns if the run was successful</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="dt">bool</span> run_head();</a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="co">// returns text to display, may be empty</span></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="bu">std::</span>string read_head() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb6-13" title="13"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb6-14" title="14">    <span class="co">// returns a change in state</span></a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="dt">bool</span> byte_state (<span class="dt">bool</span> inState, <span class="at">const</span> Byte &amp; in) <span class="at">const</span>;</a>
<a class="sourceLine" id="cb6-16" title="16"></a>
<a class="sourceLine" id="cb6-17" title="17">    <span class="bu">std::</span>unordered_set &lt;<span class="bu">std::</span>string&gt; flags;</a>
<a class="sourceLine" id="cb6-18" title="18"></a>
<a class="sourceLine" id="cb6-19" title="19">    <span class="bu">std::</span>unordered_map &lt;<span class="bu">std::</span>string, <span class="bu">std::</span>forward_list &lt;Byte&gt;&gt; dialogue;</a>
<a class="sourceLine" id="cb6-20" title="20"></a>
<a class="sourceLine" id="cb6-21" title="21">    byte_itr playHead, playHeadEnd;</a>
<a class="sourceLine" id="cb6-22" title="22">};</a></code></pre></div>
<p>Implementing these functions is very similar to the stand alone function I wrote before. The <em>ADF</em> structure requires byte-strings to start with <code>SAID_TEXT</code>, we specify this so we can use <code>SAID_TEXT</code> as a sentential to halt. When the VM picks back up we can grantee <code>playHead</code> is either <code>SAID_TEXT</code> or <code>playHeadEnd</code>.</p>
<p>Re-writing the standalone <code>run_string()</code> example function for our class certainly looks larger, but the logic now checks for our sentinel and holds the play head properly.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">bool</span> VM::run_head()</a>
<a class="sourceLine" id="cb7-2" title="2">{</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="cf">if</span> (playHead == playHeadEnd)</a>
<a class="sourceLine" id="cb7-4" title="4">        <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="co">// our run_head() should always start on a SAID_TEXT, or end</span></a>
<a class="sourceLine" id="cb7-7" title="7">    playHead++;</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="cf">while</span> (playHead != playHeadEnd <span class="kw">and</span> playHead-&gt;function != Byte::SAID_TEXT)</a>
<a class="sourceLine" id="cb7-10" title="10">    {</a>
<a class="sourceLine" id="cb7-11" title="11">        <span class="cf">switch</span> (playHead-&gt;function)</a>
<a class="sourceLine" id="cb7-12" title="12">        {</a>
<a class="sourceLine" id="cb7-13" title="13">        <span class="cf">case</span> Byte::SAID_TEXT:</a>
<a class="sourceLine" id="cb7-14" title="14">            <span class="bu">std::</span>cout &lt;&lt; playHead-&gt;text &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb7-15" title="15">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb7-16" title="16">        <span class="cf">case</span> Byte::LINK_TO:</a>
<a class="sourceLine" id="cb7-17" title="17">            {</a>
<a class="sourceLine" id="cb7-18" title="18">                <span class="at">const</span> <span class="kw">auto</span> headText {playHead-&gt;text};</a>
<a class="sourceLine" id="cb7-19" title="19"></a>
<a class="sourceLine" id="cb7-20" title="20">                <span class="co">// be weary, unordered_map::at() will throw</span></a>
<a class="sourceLine" id="cb7-21" title="21">                <span class="co">// if headText isn&#39;t a valid key!</span></a>
<a class="sourceLine" id="cb7-22" title="22">                playHead = dialogue.at (headText).begin();</a>
<a class="sourceLine" id="cb7-23" title="23">                playHeadEnd = dialogue.at (headText).end();</a>
<a class="sourceLine" id="cb7-24" title="24"></a>
<a class="sourceLine" id="cb7-25" title="25">                <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb7-26" title="26">            }</a>
<a class="sourceLine" id="cb7-27" title="27">        <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb7-28" title="28">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb7-29" title="29">        }</a>
<a class="sourceLine" id="cb7-30" title="30"></a>
<a class="sourceLine" id="cb7-31" title="31">        playHead++;</a>
<a class="sourceLine" id="cb7-32" title="32">    }</a>
<a class="sourceLine" id="cb7-33" title="33"></a>
<a class="sourceLine" id="cb7-34" title="34">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb7-35" title="35">}</a></code></pre></div>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
<h2 id="vm---file-reader">VM - File Reader</h2>
<p>Constructing our byte-strings by reading the text files first requires formatting. I really like <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">markdown</a> so I based <em>ADF</em> around it. A line-based formatting approach makes for easy programming, and can interfere with stylized/rich text formatting like <a href="http://www.pindari.com/rtf1.html">RTF</a>.</p>
<p>When creating <em>ADF</em>’s formatting we only had to consider two parts; how to assign byte-strings a name for later reference, and how to specify the type per byte. Naming byte-strings was easy, any special character(s) to make a line or block stand out will do. Now specifying byte type certainly needs to be a key-value pair with some short hands for common functions.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb8-1" title="1"><span class="fu"># Esme_Success</span></a>
<a class="sourceLine" id="cb8-2" title="2">I&#39;ll be right there.</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="bn">    ~name: Esme</span></a>
<a class="sourceLine" id="cb8-4" title="4">Esme is on her way.</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="bn">    ~name: Entity</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="bn">    ~set: dl_someone_enroute</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="bn">    ~set: dl_esme_spoke</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="bn">    ~special: sound_off</span></a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="fu"># Rakesh_Success</span></a>
<a class="sourceLine" id="cb8-11" title="11">Patience, if you please.</a>
<a class="sourceLine" id="cb8-12" title="12"><span class="bn">    ~name: Rakesh</span></a>
<a class="sourceLine" id="cb8-13" title="13">Rakesh is on his way.</a>
<a class="sourceLine" id="cb8-14" title="14"><span class="bn">    ~name: Entity</span></a>
<a class="sourceLine" id="cb8-15" title="15"><span class="bn">    ~set: dl_someone_enroute</span></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="bn">    ~set: dl_rakesh_spoke</span></a>
<a class="sourceLine" id="cb8-17" title="17"><span class="bn">    ~special: sound_off</span></a></code></pre></div>
<p>This example shows we used ‘#’ to mark the start of a new byte-string. We enclose byte types in <code>~function:</code> and the byte text as anything afterwards. Lines without a <code>~function:</code> at the start are treated as <code>~SAID_TEXT:</code>, our shorthand.</p>
<p>Reading our line based files will look like this, proper error checking will massively expand this constructor, but it’s well worth it.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1">VM::VM (<span class="at">const</span> <span class="bu">std::</span>string &amp; filename)</a>
<a class="sourceLine" id="cb9-2" title="2">{</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="bu">std::</span>ifstream infile (filename);</a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="cf">if</span> (!infile.is_open())</a>
<a class="sourceLine" id="cb9-5" title="5">        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error {<span class="st">&quot;couldn&#39;t open file! &quot;</span> + filename};</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="bu">std::</span>string line;</a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="bu">std::</span>forward_list &lt;Byte&gt; * writingTo = <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb9-9" title="9">    <span class="cf">while</span> (<span class="bu">std::</span>getline (infile, line))</a>
<a class="sourceLine" id="cb9-10" title="10">    {</a>
<a class="sourceLine" id="cb9-11" title="11">        line = trim_whitespace (line);</a>
<a class="sourceLine" id="cb9-12" title="12">        <span class="cf">switch</span> (line [<span class="dv">0</span>])</a>
<a class="sourceLine" id="cb9-13" title="13">        {</a>
<a class="sourceLine" id="cb9-14" title="14">        <span class="cf">case</span> <span class="ch">&#39;#&#39;</span>:</a>
<a class="sourceLine" id="cb9-15" title="15">            <span class="co">// we create our lists backwards with push_front()</span></a>
<a class="sourceLine" id="cb9-16" title="16">            <span class="cf">if</span> (writingTo != <span class="kw">nullptr</span>)</a>
<a class="sourceLine" id="cb9-17" title="17">                writingTo-&gt;reverse();</a>
<a class="sourceLine" id="cb9-18" title="18"></a>
<a class="sourceLine" id="cb9-19" title="19">            <span class="co">// name new byte-string</span></a>
<a class="sourceLine" id="cb9-20" title="20">            writingTo = &amp;dialogue [line.substr (<span class="dv">1</span>)];</a>
<a class="sourceLine" id="cb9-21" title="21">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb9-22" title="22">        <span class="cf">case</span> <span class="ch">&#39;~&#39;</span>:</a>
<a class="sourceLine" id="cb9-23" title="23">            <span class="cf">if</span> (writingTo != <span class="kw">nullptr</span>)</a>
<a class="sourceLine" id="cb9-24" title="24">            {</a>
<a class="sourceLine" id="cb9-25" title="25">                <span class="co">// is function of name:</span></a>
<a class="sourceLine" id="cb9-26" title="26">                <span class="at">const</span> <span class="kw">auto</span> colonPoint {line.find (<span class="ch">&#39;:&#39;</span>)};</a>
<a class="sourceLine" id="cb9-27" title="27">                <span class="at">const</span> <span class="kw">auto</span> functionName {line.substr (<span class="dv">1</span>, colonPoint-<span class="dv">1</span>)};</a>
<a class="sourceLine" id="cb9-28" title="28">                <span class="at">const</span> <span class="kw">auto</span> functionText {trim_whitespace (line.substr (colonPoint))};</a>
<a class="sourceLine" id="cb9-29" title="29"></a>
<a class="sourceLine" id="cb9-30" title="30">                writingTo-&gt;push_front (Byte {functionName, functionText});</a>
<a class="sourceLine" id="cb9-31" title="31">            }</a>
<a class="sourceLine" id="cb9-32" title="32">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb9-33" title="33">        <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb9-34" title="34">            <span class="co">// is function SAID_TEXT</span></a>
<a class="sourceLine" id="cb9-35" title="35">            <span class="cf">if</span> (writingTo != <span class="kw">nullptr</span>)</a>
<a class="sourceLine" id="cb9-36" title="36">                writingTo-&gt;push_front (Byte {Byte::SAID_TEXT, line});</a>
<a class="sourceLine" id="cb9-37" title="37">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb9-38" title="38">        }</a>
<a class="sourceLine" id="cb9-39" title="39">    }</a>
<a class="sourceLine" id="cb9-40" title="40">}</a></code></pre></div>
<p>This format is reliant on the first character on a line, this makes it easy to expand for more shorthand or unique functions. Keep in mind this sample code doesn’t check for any potentially extreme errors, like reading the same <code># name</code>. Validating function inputs will be the bulk of your error checking, it’s very important to highlight any potential syntax or logic errors.</p>
<p>I’ll write out the <code>trim_whitespace()</code> function, and the string based type Byte constructor for completions sake.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">inline</span> <span class="bu">std::</span>string trim_whitespace (<span class="at">const</span> <span class="bu">std::</span>string &amp; in)</a>
<a class="sourceLine" id="cb10-2" title="2">{</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="dt">unsigned</span> index {<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="cf">while</span> (index &lt; in.length() <span class="kw">and</span> <span class="bu">std::</span>isspace (in [index]))</a>
<a class="sourceLine" id="cb10-5" title="5">        index++;</a>
<a class="sourceLine" id="cb10-6" title="6"></a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="cf">if</span> (index &gt;= in.length() <span class="kw">or</span> index == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb10-8" title="8">        <span class="cf">return</span> in;</a>
<a class="sourceLine" id="cb10-9" title="9"></a>
<a class="sourceLine" id="cb10-10" title="10">    <span class="cf">return</span> in.substr (index);</a>
<a class="sourceLine" id="cb10-11" title="11">}</a>
<a class="sourceLine" id="cb10-12" title="12"></a>
<a class="sourceLine" id="cb10-13" title="13">Byte::Byte (<span class="bu">std::</span>string type, <span class="bu">std::</span>string value)</a>
<a class="sourceLine" id="cb10-14" title="14">    : text (value)</a>
<a class="sourceLine" id="cb10-15" title="15">{</a>
<a class="sourceLine" id="cb10-16" title="16">    <span class="kw">struct</span></a>
<a class="sourceLine" id="cb10-17" title="17">    {</a>
<a class="sourceLine" id="cb10-18" title="18">        <span class="bu">std::</span>string key;</a>
<a class="sourceLine" id="cb10-19" title="19">        <span class="dt">EType_t</span> value;</a>
<a class="sourceLine" id="cb10-20" title="20">    } <span class="at">static</span> <span class="at">const</span> tostr[] = {</a>
<a class="sourceLine" id="cb10-21" title="21">        {<span class="st">&quot;set&quot;</span>, SET},</a>
<a class="sourceLine" id="cb10-22" title="22">        {<span class="st">&quot;special&quot;</span>, SPECIAL},</a>
<a class="sourceLine" id="cb10-23" title="23">        {<span class="st">&quot;name&quot;</span>, NAME},</a>
<a class="sourceLine" id="cb10-24" title="24">    };</a>
<a class="sourceLine" id="cb10-25" title="25"></a>
<a class="sourceLine" id="cb10-26" title="26">    <span class="co">// tolower the entire input</span></a>
<a class="sourceLine" id="cb10-27" title="27">    <span class="bu">std::</span>transform (type.begin(), type.end(), type.begin(), ::tolower);</a>
<a class="sourceLine" id="cb10-28" title="28"></a>
<a class="sourceLine" id="cb10-29" title="29">    <span class="cf">for</span> (<span class="kw">auto</span> &amp; i : tostr)</a>
<a class="sourceLine" id="cb10-30" title="30">        <span class="cf">if</span> (i.key == type)</a>
<a class="sourceLine" id="cb10-31" title="31">            function = i.value;</a>
<a class="sourceLine" id="cb10-32" title="32">}</a></code></pre></div>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
<h1 id="conclusion">Conclusion</h1>
<p>When designing a system it’s of utmost importance to consider the following:</p>
<ol type="1">
<li>Error Checking</li>
<li>Legibility</li>
<li>Expandability</li>
</ol>
<p>While programming in general the ability to debug code should be in the back of your head. While designers are using your system it should be a forced, implicit part of the system. At any point stop and think “How could this function be misused?”, “What if this is misspelled?” and try to flag that case. Your system should check designer’s code vigorously.</p>
<p>Writing your own language puts you in a unique situation of having to teach it. Do yourself a favor and make it simple and transparent, use as much English as possible. “Syntactic sugar” should be avoided, too many enigmatic percent signs and asterisks only cause confusion and a trip to the manual, even for yourself. I’d recommend making use of braces or parenthesis if applicable, white space can be difficult to debug and program for.</p>
<p>More functionality will always be around the corner, be ready to quickly try out ideas. Make sure you can account for functions with multiple parameters. Add an escape character in case your special characters are needed in-dialogue.</p>
<p>Creating a virtual machine can be all the fun of making your own language without all the hassle of compiler architecture. Good luck, try to make the most of it!</p>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
</body>
</html>
