<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Garrett Hale" />
  <title>Game Dialogue Systems</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../document.css" />
</head>
<body>
<h1 id="systems-intent">Systems Intent</h1>
<p>Dialogue can be the focus of many games, if robust dialogue is the foremost feature then it’s important to create or use a system that can account for the plethora of data and logistics behind simple game dialogue.</p>
<p>Some games, like Morrowind use dialogue for linear quest interactions, and Morrowind houses a healthy amount of quests. In this scenario the game needs to track multiple quest progressions, though that’s the end of it, linear state.</p>
<p>Telltale’s “The Walking Dead” uses a branching paths story in a hierarchic structure, one choice always leads to a new choice, never repeating. The hierarchy inherently provides structure used to create branches and reduce branches back into a linear path.</p>
<p>Our team’s game “Vessels”, we had a finite cast of characters and a spider-web of dialogue for the player to unravel. We used <a href="https://twinery.org/">Twinery</a> to draft our story as the node-based system and robust state machine handles our cyclical, evolving story. In Unreal we developed our own virtual machine to handle dialogue, sewing programming and dialogue into one text file. With a virtual machine like this we could create branching paths and out of order execution for player progression.</p>
<p>When designing any system it’s important to only pay for what you use. Having a firmly low scope means saying no to some requests, it means building a system that simply can’t do everything. By design the limitations can bring benefits, you can make assumptions of what designers are trying to do and automatically react or properly throw errors. It’s very easy to believe you’ll need the most robust system, this rarely reduces time spent coding for both the tools developer and content creators.</p>
<p>It’s very important to make sure your system can be debugged, even those not using virtual machines or any seemingly simple system. Error checking is little work when automated and a major headache if left invisible.</p>
<p>Always compile <code>-Wall -Wextra</code> you cowards.</p>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
<h1 id="vessels-and-virtual-machines">Vessels and Virtual Machines</h1>
<p>Vessels originally planned for a open world approach. The tool <a href="https://www.inklestudios.com/ink/"><em>ink</em></a> seemed promising, but didn’t fit our proposed design requirements. Looking at it now we seem to have implemented most of <em>ink</em>’s features and architecture with more legible syntax, if it worked with Unreal and I dug deeper I’m sure we would’ve picked this tool.</p>
<p>The benefit of a virtual machine like <em>ink</em> or the “Airlock Dialogue File” (<em>ADF</em>) is allowing designers control over such immense pathways and state changes. Typically if a third party is distributing their dialogue system it’ll be some sort of virtual machine, reason being that virtual machines can cover a lot of functionality. When marketing a system like this it sells to boast a large feature list and appeal to every possible edge case, this can be costly for designers as you end up working with some unpopular, esoteric, or illegible programming language like Rust.</p>
<p>By curbing these potential downsides restrained systems flourish, <em>ADF</em> handles 4,948 lines of dialogue with 5,699 written operators for flow control. This would’ve been over 5,699 nodes in blueprint without this system to ease reading and writing; not to mention cut out Unreal’s atrocious boot time.</p>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
<h1 id="vm---data-structures">VM - Data Structures</h1>
<p>First off a quick “VM 101”. We’ll fudge some of the specifics here but a virtual machine uses programmer-defined bytecode instructions to operate on top of your standard CPU instructions. The performance of virtual machines is always slower than raw machine code, yet faster than most interpreted languages. The defined bytecode can be very basic arithmetic and jumps, just like enterprise CPUs.</p>
<p>You should define specific game or dialogue related bytecode. <em>ADF</em> has no mathematics builtin, every operation is built to aid in dialogue cosmetics and flow. Code samples like below will be shortened and <em>UE4</em> types will be replaced with <em>stl</em> variants.</p>
<p>As reference I’ve attached this sample of dialogue the <em>ADF</em> parses and uses in our game.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown"><code class="sourceCode markdown"><a class="sourceLine" id="cb1-1" title="1"><span class="fu"># Question_Suicide</span></a>
<a class="sourceLine" id="cb1-2" title="2">Yes... I am. And... I&#39;ve asked you to not talk to me about this.</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="bn">    ~name: Esme</span></a>
<a class="sourceLine" id="cb1-4" title="4">Peyton, please... I respect the subjects you don&#39;t want to discuss.</a>
<a class="sourceLine" id="cb1-5" title="5">Please do not bring Marv up with me.</a>
<a class="sourceLine" id="cb1-6" title="6">This subject seems to upset her most...</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="bn">    ~name: Entity</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="bn">    ~interest: Esme_Upset by Marv&#39;s suicide</span></a>
<a class="sourceLine" id="cb1-9" title="9">We can use this.</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="bn">    ~link: ASPEYTON_QUESTION</span></a></code></pre></div>
<p>Each piece of dialogue and function (the ~ part) is stored as a “byte” in the machine. “Byte” used lightly as we keep the whole string in this bytecode rather than referencing it elsewhere in memory.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">struct</span> Byte</a>
<a class="sourceLine" id="cb2-2" title="2">{</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">enum</span> <span class="dt">EType_t</span></a>
<a class="sourceLine" id="cb2-4" title="4">    {</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="co">// COSMETIC</span></a>
<a class="sourceLine" id="cb2-6" title="6">        SAID_TEXT,</a>
<a class="sourceLine" id="cb2-7" title="7">        CHOICE_TEXT,</a>
<a class="sourceLine" id="cb2-8" title="8">        NAME,</a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">        <span class="co">// CONDITIONALS</span></a>
<a class="sourceLine" id="cb2-11" title="11">        CONDITIONAL,</a>
<a class="sourceLine" id="cb2-12" title="12">        INVERSE_CONDITIONAL,</a>
<a class="sourceLine" id="cb2-13" title="13">        NAND_CONDITIONAL,</a>
<a class="sourceLine" id="cb2-14" title="14">        OR_CONDITIONAL,</a>
<a class="sourceLine" id="cb2-15" title="15">        ALREADY_READ,</a>
<a class="sourceLine" id="cb2-16" title="16">        AS_CREW,</a>
<a class="sourceLine" id="cb2-17" title="17"></a>
<a class="sourceLine" id="cb2-18" title="18">        <span class="co">// MUTATORS</span></a>
<a class="sourceLine" id="cb2-19" title="19">        SET,</a>
<a class="sourceLine" id="cb2-20" title="20">        UNSET,</a>
<a class="sourceLine" id="cb2-21" title="21">        INTEREST,</a>
<a class="sourceLine" id="cb2-22" title="22">        SPECIAL,</a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24">        <span class="co">// FLOW CONTROL</span></a>
<a class="sourceLine" id="cb2-25" title="25">        ALTER_START,</a>
<a class="sourceLine" id="cb2-26" title="26">        LINK_TO,</a>
<a class="sourceLine" id="cb2-27" title="27">        BREAK_TO,</a>
<a class="sourceLine" id="cb2-28" title="28">    } function;</a>
<a class="sourceLine" id="cb2-29" title="29"></a>
<a class="sourceLine" id="cb2-30" title="30">    <span class="bu">std::</span>string text;</a>
<a class="sourceLine" id="cb2-31" title="31"></a>
<a class="sourceLine" id="cb2-32" title="32">    <span class="dt">unsigned</span> originLine;</a>
<a class="sourceLine" id="cb2-33" title="33">    <span class="dt">unsigned</span> indent;</a>
<a class="sourceLine" id="cb2-34" title="34">};</a></code></pre></div>
<p>Structurally, this isn’t what most people expect, and sadly that means I’ve created a poor mental model for you.</p>
<p>So we create each byte with two main variables for our machine to operate on. Each <code>EType_t</code> tells the VM what to do with the byte’s <code>text</code> variable, for merely displaying a <code>SAID_TEXT</code> operator will print the <code>text</code> variable on-screen. The <code>SET</code> function will store a value of true in the VM, with <code>text</code> as the key, for later state retrieval.</p>
<p>Most virtual machines are programmed to read bytecode until some sentinel is met. <em>ADF</em> has separated functions for reading text, and operating on the VM state. In both cases <em>ADF</em> reads a <code>SAID_TEXT</code> then continues to read any other <code>EType_t</code> until it reaches a <code>SAID_TEXT</code> again. When just reading <em>ADF</em> only prints the initial <code>SAID_TEXT</code> and checks for cosmetics that follow. When operating <em>ADF</em> will set variables, potentially prepare another byte-string to read, and finally move forward in the current byte-string, where reading and operating will start for the next calls.</p>
<p>To help understand how we craft our Byte I’ll take the last example and write it as a array in C++ using the <code>struct Byte</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1">Byte Question_Suicide[] = {</a>
<a class="sourceLine" id="cb3-2" title="2">    {Byte::SAID_TEXT, <span class="st">&quot;Yes... I am. And... I&#39;ve asked you to not talk to me about this.&quot;</span>},</a>
<a class="sourceLine" id="cb3-3" title="3">    {Byte::NAME,      <span class="st">&quot;Esme&quot;</span>},</a>
<a class="sourceLine" id="cb3-4" title="4">    {Byte::SAID_TEXT, <span class="st">&quot;Peyton, please... I respect the subjects you don&#39;t want to discuss.&quot;</span>},</a>
<a class="sourceLine" id="cb3-5" title="5">    {Byte::SAID_TEXT, <span class="st">&quot;Please do not bring Marv up with me.&quot;</span> },</a>
<a class="sourceLine" id="cb3-6" title="6">    {Byte::SAID_TEXT, <span class="st">&quot;This subject seems to upset her most...&quot;</span>},</a>
<a class="sourceLine" id="cb3-7" title="7">    {Byte::NAME,      <span class="st">&quot;Entity&quot;</span>},</a>
<a class="sourceLine" id="cb3-8" title="8">    {Byte::INTEREST,  <span class="st">&quot;Esme_Upset by Marv&#39;s suicide&quot;</span>},</a>
<a class="sourceLine" id="cb3-9" title="9">    {Byte::SAID_TEXT, <span class="st">&quot;We can use this.&quot;</span>},</a>
<a class="sourceLine" id="cb3-10" title="10">    {Byte::LINK_TO,   <span class="st">&quot;ASPEYTON_QUESTION&quot;</span>},</a>
<a class="sourceLine" id="cb3-11" title="11">};</a></code></pre></div>
<p>A typical virtual machine will try to read the whole byte-string or finish prematurely, throw an error, and give up. This is why we track the last read <code>SAID_TEXT</code> operator and re-feed the list at that start point, making <code>SAID_TEXT</code> the “end” byte like <code>'\0'</code> for c-strings.</p>
<p>This example code conversion is mostly accurate with the caveat that we can’t create a custom named <code>Question_Suicide</code> array for what’s declared in a text file. We opted to use a <code>std::map &lt;std::string, std::list &lt;Byte&gt;&gt;</code> to achieve this run-time array creation, where the <code>std::string</code> key is “Question_Suicide” and the rest, is the byte-string in linked list form.</p>
<blockquote>
<p>When actually implementing I’d use <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a> and <a href="https://en.cppreference.com/w/cpp/container/forward_list"><code>std::forward_list</code></a> for simpler insertion complexity.</p>
</blockquote>
<p>Byte-strings can take form of many data structures. Arrays will be faster to operate on but potentially slower to build. Linked lists will be quick to build and slower to operate. For this reason our dialogue system builds linked lists at the start of the game and operates over them during dialogue. Maps are surprisingly fast for how feature rich they are; we use maps to title and track the individual dialogue byte-strings.</p>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
<h1 id="vm---operation">VM - Operation</h1>
<p>The simplest virtual machine is a function taking some container to operate over; I’ll demonstrate the easiest, hardest to work with implementation.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">bool</span> run_string (<span class="at">const</span> <span class="bu">std::</span>forward_list &lt;Byte&gt; data)</a>
<a class="sourceLine" id="cb4-2" title="2">{</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="cf">for</span> (<span class="kw">auto</span> &amp; i: data)</a>
<a class="sourceLine" id="cb4-4" title="4">    {</a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="cf">switch</span> (i.function)</a>
<a class="sourceLine" id="cb4-6" title="6">        {</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="cf">case</span> Byte::SAID_TEXT:</a>
<a class="sourceLine" id="cb4-8" title="8">            <span class="bu">std::</span>cout &lt;&lt; i.text &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb4-9" title="9">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="cf">default</span>:</a>
<a class="sourceLine" id="cb4-11" title="11">            <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;unhandled function!&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb4-12" title="12">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb4-13" title="13">        }</a>
<a class="sourceLine" id="cb4-14" title="14">    }</a>
<a class="sourceLine" id="cb4-15" title="15">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb4-16" title="16">}</a></code></pre></div>
<p>This function may be enough for you, but I’d like to leverage objects to make some relationships between our dialogue and actors. Firstly any data from our byte-strings will be lost without somewhere to keep it. Second this operates an entire byte-string at a time, while useful for more programmatic cases we need to stop, and wait for the player to continue the reading. By making a class to house and run our dialogue we can attach this to actors and directly associate text with them.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> VM</a>
<a class="sourceLine" id="cb5-2" title="2">{</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="co">// loads text file into our &quot;dialogue&quot; variable</span></a>
<a class="sourceLine" id="cb5-5" title="5">    VM (<span class="at">const</span> <span class="bu">std::</span>string &amp; filename);</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">using</span> byte_itr = <span class="bu">std::</span>forward_list &lt;Byte&gt;::const_iterator;</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="co">// operates based on the playHead</span></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="dt">void</span> run_string();</a>
<a class="sourceLine" id="cb5-11" title="11"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="co">// variables can be anything!</span></a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="bu">std::</span>string currentSpeaker;</a>
<a class="sourceLine" id="cb5-14" title="14">    <span class="bu">std::</span>unordered_set &lt;<span class="bu">std::</span>string&gt; flags;</a>
<a class="sourceLine" id="cb5-15" title="15"></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="co">// what a mouthful!</span></a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="bu">std::</span>unordered_map &lt;<span class="bu">std::</span>string, <span class="bu">std::</span>forward_list &lt;Byte&gt;&gt; dialogue;</a>
<a class="sourceLine" id="cb5-18" title="18"></a>
<a class="sourceLine" id="cb5-19" title="19">    <span class="co">// track dialogue progression</span></a>
<a class="sourceLine" id="cb5-20" title="20">    byte_itr playHead, playHeadEnd;</a>
<a class="sourceLine" id="cb5-21" title="21">};</a></code></pre></div>
<p>In <em>UE4</em> finding a place for persistent data may be daunting. Creating a basic C++ “Game Mode” class with accessible data will persist through the game, just remember to reset during a game over or save/load. With this your VM function will pull and push data from <em>UE4</em>’s global variables, like your game mode class.</p>
<p>For this document I’m going to continue with the custom VM class definition.</p>
<p>When managing dialogue you’ll likely want to display text, change state, and move the play head forward. We benefit from separating this into at least two functions, you might want to display text more than once, or skip ahead via a fast-forward key. The change is minor for the header, but requires some planning.</p>
<p>It’s also important to find out what data needs to come out of your VM operations. For displaying text it’s usually just a <code>std::string</code>, running could return full state, a error code, or nothing! My advice here will be to try and catch your errors while loading dialogue.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">class</span> VM</a>
<a class="sourceLine" id="cb6-2" title="2">{</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb6-4" title="4">    VM (<span class="at">const</span> <span class="bu">std::</span>string &amp; filename);</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">using</span> byte_itr = <span class="bu">std::</span>forward_list &lt;Byte&gt;::const_iterator;</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="co">// returns if the run was successful</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="dt">bool</span> run_string();</a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="co">// returns text to display, may be empty</span></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="bu">std::</span>string read_string() <span class="at">const</span>;</a>
<a class="sourceLine" id="cb6-13" title="13"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb6-14" title="14">    <span class="bu">std::</span>string currentSpeaker;</a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="bu">std::</span>unordered_set &lt;<span class="bu">std::</span>string&gt; flags;</a>
<a class="sourceLine" id="cb6-16" title="16"></a>
<a class="sourceLine" id="cb6-17" title="17">    <span class="bu">std::</span>unordered_map &lt;<span class="bu">std::</span>string, <span class="bu">std::</span>forward_list &lt;Byte&gt;&gt; dialogue;</a>
<a class="sourceLine" id="cb6-18" title="18"></a>
<a class="sourceLine" id="cb6-19" title="19">    byte_itr playHead, playHeadEnd;</a>
<a class="sourceLine" id="cb6-20" title="20">};</a></code></pre></div>
<!-- vim: set cc=80: -->
<!-- vim: set spell: -->
</body>
</html>
