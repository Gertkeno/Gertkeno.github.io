<!-- Made with gert-ctml version#1.0.0 -->
<html>
	<head>
		<title>Garrett Hale Portfolio</title>
		<link href="../project.css" rel="stylesheet" type="text/css">
		<meta charset="uft-8">
		<script src="../legendary.js"></script>
	</head>
	<body onload="add_legend_entries()">
		<h1>Portfolio</h1>
		<h2>Legend</h2>
		<ul id="legend"></ul>
		<br>
		<h2 id="Videos" class="chapter">Video Evidence of Stuff I've Done</h2>
		<p>The following is usually in-dev video games, since that's when I usually end up making videos.</p>
		<p>
			This is a sample of <a href="https://bitbucket.org/Gertkeno/dadslayersix/downloads/">"Dad Slayer Six"</a> a wave-based twin stick shooter with power ups and a turret thing.
			I made this for a co-worker who hated Panera. I later had my friend do audio, music, and some art.
		</p>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/0rdo_x2oDKE?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
		<p>
			My goodbye project for SDL2 was <a href="https://bitbucket.org/Gertkeno/meme-game/downloads/">"Meme Game"</a> made for a specific community, of which I even got some story and art help from!
			It's a astroid ship doing boss fights, and boss fights are fun to program.
		</p>
		<p>This specific video is some muted basic game play.</p>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/STzDAmqXj5c?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
		<p>And this is the intended streamer playing the finished game.</p>
		<iframe src="https://www.youtube.com/embed/Z1RxPUxIggQ?rel=0&amp;showinfo=0&amp;start=5925" width="560" height="315" frameborder="0" allowfullscreen></iframe>
		<p>
			After all this 2D SDL2 stuff I had an itch for OpenGL since I knew it would not only allow 3D but more complex, fun rendering in general.
			I started with a sequel to "Meme Game" aptly called <a href="https://bitbucket.org/Gertkeno/meme-game-23d/downloads/">"Meme Game 2: 3D"</a>, I'm happy with the front-end result, but a lot of the rendering code is terrible.
			Oh well that's what first projects are for.
		</p>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/ZObwwNiPOq4?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
		<p>The following is a little trailer I made for "Meme Game 2", with less debugging spheres and more thanking.</p>
		<iframe width="560" height="315" src="https://www.youtube.com/embed/p9rINCeBq4s?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
		<h2 id="NotGame" class="chapter">Non-Game Stuff</h2>
		<p>
			I wrote an HTTP server in C++ using boost's ASIO library, Somewhat to prepare for Code2College teaching since I didn't have much web dev experience before that.
			It should hopefully be live at <a href="http://gerthouse.com/">gerthouse.com</a>. It's just a link aggregate site hosted on a raspberrypi, I still need to implement the SSL/HTTPS things.
		</p>
		<p>
			After teaching at Code2College I got a job in web development thanks to Jorge's recommendation. No one asked me to do C++, but I still had some fun learning that world.
			I'd be happy to work more web dev jobs eitherway.
		</p>
		<br>
		<p>
			This one is almost game related, I really wanted to compile assets instead of packaging loose jpgs and wavefronts.
			I didn't end up doing that for my first 3D game but I made a tool to help with the wavefront data.
			<a href="https://github.com/Gertkeno/gert-wavefrontc">My wavefront to C converter</a> is a pretty gross off and on project that just parses a <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront file</a> and spits out two variables, a array of floats to represent the object, and the length of that array.
		</p>
		<p>Example from:</p>
		<pre>
# Blender v2.72 (sub 0) OBJ File: 'test.blend'
# www.blender.org
o Cube
v 0.309889 -1.000000 -1.000000
v 0.309889 -1.000000 1.000000
v -0.323454 -1.000000 1.000000
...
vt 0.431268 0.607233
vt 0.567842 0.607233
vt 0.567842 1.000000
...
vn 0.000000 -1.000000 0.000000
vn -0.000000 0.161600 0.986800
vn 1.000000 0.000000 0.000000
...
f 14/66/20 18/67/20 10/60/20
f 38/33/44 16/24/44 37/75/44
f 7/56/47 10/60/47 8/57/47
</pre>
		<p>To:</p>
		<pre>
const float test_vertices[] = {
0.309889, -1.000000, 1.000000, 0.431268, 0.607233, 0.000000, -1.000000, 0.000000,
-0.323454, -1.000000, 1.000000, 0.567842, 0.607233, 0.000000, -1.000000, 0.000000,
...
-0.323454, 1.038916, -0.937544, 0.849069, 0.113096, -1.000000, -0.005900, 0.001800, };
const unsigned int test_len = 216;
</pre>
		<p>
			<code>test_vertices</code> is much more consumeable for OpenGL buffers, and easily compileable. Like how <code>xxd -i</code> works except specifically for Wavefront files.
			Sadly Wavefront files suck so this little app isn't useful for most devs.
		</p>

		<h2 id="Sample" class="chapter">Code Snippets</h2>
		<p>It's always tough to choose good bits of code. Two weeks from now I'll learn some new pattern or library that make previously awesome code redundant or overcomplicated.</p>
		<p>
			This is some controller code that reads from SDL2's event queue to set 0.0 - 1.0 for each input configured in <code>_controls</code>.
			The main reason I like this code is the use of function pointers and standardizing joysticks, keyboard, and mouse inputs to one class.
		</p>
		<pre>
template&lt;typename Func&gt;
void _search_input( Input::type_t t, int id, Func&& x )
{
    for( auto & input: _controls )
    {
        if( input.myType != t ) continue;
        if( input.button != id ) continue;

        x( &input );
    }
}

void digital_press(Input* t)
{
    if( t-&gt;held &lt; 1.0f )
        t-&gt;framePress = true;
    t-&gt;held = 1.0f;
}

void digital_release(Input* t)
{
    t-&gt;held = 0.0f;
}

void Controller::manage_inputs( const SDL_Event* e )
{
    auto stateDigital{ digital_release };
    //get press/release, if axis apply and return
    switch( e-&gt;type )
    {
    case SDL_JOYBUTTONDOWN:
    case SDL_KEYDOWN:
    case SDL_MOUSEBUTTONDOWN:
        stateDigital = digital_press;
        break;
    case SDL_JOYAXISMOTION:
        _search_input( Input::type_t::JOYAXIS, e-&gt;jaxis.axis, [e](Input* t)
        {
            t-&gt;held = static_cast&lt;float&gt;(e-&gt;jaxis.value) / t-&gt;axisMax;
            if( t-&gt;held &lt; AXIS_DEAD_ZONE )
                t-&gt;held = 0.0f;
            else if( t-&gt;held &gt; 1.0f )
                t-&gt;held = 1.0f;

            if( t-&gt;axisPass and t-&gt;held &lt; AXIS_RESET_THRESHOLD )
                t-&gt;axisPass = false;
            else if( not t-&gt;axisPass and t-&gt;held &gt; AXIS_PRESS_THRESHOLD )
            {
                t-&gt;framePress = true;
                t-&gt;axisPass = true;
            }
        });
        return;
    }

    //apply digital press/release
    switch( e-&gt;type )
    {
    case SDL_KEYUP:
    case SDL_KEYDOWN:
        _search_input( Input::type_t::KEYBOARD, e-&gt;key.keysym.sym, stateDigital );
        break;
    case SDL_MOUSEBUTTONUP:
    case SDL_MOUSEBUTTONDOWN:
        _search_input( Input::type_t::MOUSE, e-&gt;button.button, stateDigital );
        break;
    case SDL_JOYBUTTONUP:
    case SDL_JOYBUTTONDOWN:
        _search_input( Input::type_t::JOYBUTTON, e-&gt;jbutton.button, stateDigital );
        break;
    }
}
</pre>
	<p>I don't like the two switch statements with almost the same filters, though I couldn't find a way to collapse the two without repeating a few other statements.</p>
	</body>
</html>
